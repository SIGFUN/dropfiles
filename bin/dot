#!/bin/bash -O extglob

# Executable preamble
mydir="$(dirname $0)"
pushd "$mydir/.." > /dev/null; dotfiles="$(pwd)"; popd > /dev/null
libdir="${dotfiles}/lib"

# Imports
. "${libdir}/Lib.sh"
. "${libdir}/Module.sh"
. "${libdir}/CLI.sh"
. "${libdir}/Git.sh"

# Parsed options
GIT_PARSEOPT_SPEC="\
dot

Configures the home directory for use with the dotfiles repository. This will \
will perform the following ACTIONs (each ACTION may be individually supplied \
to the A,action option by its name):

omz:      Install oh-my-zsh. Since oh-my-zsh overwrites the .zshrc, the \
resulting .zshrc is copied to ~/.config/zomz, and .zshrc is replaced with a \
trampoline that imports all z-files from ~/.config. If oh-my-zsh is already \
present, this action is a no-op

hide:     Configures the repository in ~/.dotfiles to ignore untracked files

sudo:     Configure sudo(1) to remove the password timeout

merge:    Merge $HOME/.merge to $HOME

ssh:      Generates Ed25519 and RSA4K ssh keys with a random passphrases \
and adds those passphrases to the local Keychain. The default sshconfig(7) is \
also configured to use the Keychain for all hosts and to import a \
configuration file from ~/.employer/config/ssh

homebrew: Install homebrew

blueutil: Install blueutil from homebrew

$(CLI.get_stuckopt_blurb)
--
 Available options
A,action=ACTION          Performs only ACTION, rather than the entire script. \
This can be specified multiple times, in which case the ACTIONs will be \
performed in the other they were specified

z,archive=ARCHIVE-PATH   Create an gzipped archive at ARCHIVE-PATH of the \
dotfiles repository that is suitable for sharing with others. The archive will \
only capture support libraries and tools -- no personally-identifying \
information or mergeable content will be included. No ACTION will be performed

D,drop=DROP-REPOSITORY   Archives the dotfiles repository and expands the \
result into the repository clone indicated by DROP-REPOSITORY
$(CLI.get_global_blurb)
"

O_ARCHIVE=
O_DROP=
O_ACTIONS=()

# Globals
G_DEFAULT_ACTIONS=(
	"__omz"
	"__hide"
	"__sudo"
	"__merge"
	"__ssh"
	"__homebrew"
	"__blueutil"
)
G_COMMENT="Auto-generated by the dot command in the dotfiles project"
G_OMZ=$(strsmash '' \
	"https://raw.githubusercontent.com/" \
	"ohmyzsh/ohmyzsh/master/tools/install.sh" \
)

G_BREW="https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh"

G_ZSHRC="\
# $G_COMMENT.

# The (N) tells zsh to ignore glob expansion failures. By default, it will
# terminate, meaning that the new shell gets created with a failure in $?, which
# is less than ideal.
for zf in \"$HOME\"/.config/z*(N); do
	source \"\$zf\"
done

# This has to be done after oh-my-zsh has been sourced, since it sets this
# option by default for some reason.
unsetopt share_history
"

# We put the 'Host *' rule in here because it refers to the ssh key path, which
# we want to parameterize. The .config/ssh file is for static content that we
# may want to add in the future.
G_SSH_CONFIG="\
# $G_COMMENT.
Include ~/.config/ssh

# Prefer the Ed25519 for all hosts by default -- the RSA key is just for hosts
# that don't support Ed25519.
Host *
	UseKeychain yes
	AddKeysToAgent yes
"

# MARK: Utilities
function create_ssh_key()
{
	local t="$1"
	local b="$2"
	local d="$3"
	local kd="$(CLI.get_run_state_path "ssh")"
	local kf="$kd/$t"
	local bin="$dotfiles/bin"
	local libexec="$dotfiles/libexec"
	local pass=

	# Generate an ssh key. We create the key in our runstate directory to avoid
	# the prompt to overwrite an existing key (if one is already there), which
	# breaks the expect script.
	CLI.command mkdir -p "$kd"
	pass=$(${bin}/phrasing -n)
	pass+=$'\n'
	echo "$pass" | "$libexec/ssh-keygen.exp" "$t" "$b" "$kf" "$G_COMMENT"
	CLI.die_check $? "generate new ssh key"

	# Now copy the key pair to its final location and add the passphrase to the
	# Keychain. When using --apple-use-keychain, identities are discovered in
	# the keychain by path, so we have to add the keys to the agent after having
	# copied them to their final locations.
	CLI.command cp "$kf" "$d"
	CLI.command cp "$kf.pub" "$d.pub"
	echo "$pass" | "$libexec/ssh-add.exp" "$d"
	CLI.die_check $? "add new ssh key to agent"
}

# MARK: Command Implementation
function __omz()
{
	grep '# Auto-generated by the dot command' .zshrc
	if [ $? -ne 0 ]; then
		CLI.command sh -c "$(curl -fsSL "$G_OMZ")"
		CLI.die_check $? "install oh-my-zsh"

		# Write out our bootstrap .zshrc that will source the saved oh-my-zsh
		# rc.
		CLI.command mv ".zshrc" ".config/zomz"
		echo "$G_ZSHRC" > .zshrc
	fi
}

function __hide()
{
	Git.init "$HOME/.dotfiles" "$HOME" "default"
	Git.run config --local status.showUntrackedFiles no
}

function __merge()
{
	local gd="$HOME/.dotfiles"
	local wt="$dotfiles"
	local varg1=$(CLI.get_verbosity_opt "dv")
	local varg2=$(CLI.get_verbosity_opt "v" 2)
	local varg="$varg1$varg2"

	if [ "$wt" != "$HOME" ]; then
		gd="$dotfiles/.git"
	fi

	CLI.pushdir "$wt"
	CLI.command $mydir/git-ditto -G "$gd" -W "$wt" $varg ".merge" "$HOME"
	CLI.popdir
}

function __sudo()
{
	# Set up sudo(1) to only require one password entry per boot.
	sudo mkdir -p "/etc/sudoers.d"
	echo "$G_SUDOERS" | sudo tee "/etc/sudoers.d/$USER"
}

function __ssh()
{
	local i=0
	# Note that the bits option for Ed25519 is ignored -- we just supply
	# something big enough to get past ssh-keygen's argument parsing. We
	# generate the keys in our run state directory to avoid the interactive
	# prompt asking to overwrite them if they already exist.
	local key_specs=(
		"ed25519"
		"1024"
		"$HOME/.ssh/id_ed25519"
		"rsa"
		"4096"
		"$HOME/.ssh/id_rsa4k"
	)
	local ssh_config=".ssh/config"
	local conf="$G_SSH_CONFIG"

	for (( i = 0; i < ${#key_specs[@]}; i += 3 )); do
		local t="${key_specs[$(( $i + 0 ))]}"
		local b="${key_specs[$(( $i + 1 ))]}"
		local f="${key_specs[$(( $i + 2 ))]}"

		create_ssh_key "$t" "$b" "$f"
		conf+=$'\t'
		conf+="IdentityFile $f"
		conf+=$'\n'
	done

	echo "$conf" > "$ssh_config"
	CLI.command chmod 600 "$ssh_config"
}

function __homebrew()
{
	CLI.command bash -c "$(curl -fsSL "$G_BREW")"
	CLI.die_check $? "install homebrew"
}

function __blueutil()
{
	# Install blueutil, which is needed for our tiny Bluetooth switcher.
	CLI.command brew install blueutil
	CLI.die_check $? "install blueutil"
}

function __archive()
{
	CLI.pushdir "$dotfiles"
	Git.init_dotfiles

	Git.check_tree_dirty
	CLI.die_check $? "please stash or commit changes before archiving"

	Git.run archive -o "$O_ARCHIVE" --format tgz HEAD
	CLI.die_check $? "failed to create archive"
	CLI.popdir
}

function __drop()
{
	local ar="$(CLI.get_run_state_path "ar")"
	local v_arg=$(CLI.get_verbosity_opt "v")
	local head=
	local commitmsg=

	CLI.pushdir "$dotfiles"
	Git.init_dotfiles

	Git.check_tree_dirty
	#CLI.die_check $? "please stash or commit changes before archiving"

	head=$(Git.get_head_hash)
	commitmsg="dotfiles drop"

	Git.run archive -o "$ar" --format tgz HEAD
	CLI.die_check $? "create archive"

	CLI.command tar -xz${v_arg}f "$ar" -C "$O_DROP"
	CLI.die_check $? "drop archive"

	CLI.popdir
	CLI.pushdir "$O_DROP"
	Git.init "default" "default" "default"

	Git.run add --all
	CLI.die_check $? "stage files for commit"

	Git.run commit -am "$commitmsg" --trailer "Dotfiles-Tree: $head"
	CLI.die_check $? "commit drop"

	CLI.popdir
}

function validate_action()
{
	local act="$1"

	case "$act" in
	omz|hide|merge|sudo|ssh|homebrew|blueutil)
		echo "__$act"
		;;
	*)
		;;
	esac
}

function __cmd()
{
	CLI.pushdir "$HOME"
	for act in "${O_ACTIONS[@]}"; do
		$act
	done
	CLI.popdir
}

function __main()
{
	local me="$(basename ${BASH_SOURCE[0]})"

	CLI.init "$me" "$GIT_PARSEOPT_SPEC" "$@"
	eval "$(echo "$GIT_PARSEOPT_SPEC" |
		git rev-parse --parseopt --keep-dashdash --stuck-long -- "$@" \
				|| echo exit $?
	)"

	while [ $# -ne 0 ]; do
		local arg="$(CLI.parse_argument "$1")"
		local arg_opt=()
		local act=

		case "$1" in
		-A | --action=*)
			act=$(validate_action "$arg")
			if [ -z "$act" ]; then
				CLI.die_badopt "$arg" "action"
			fi

			O_ACTIONS+=("$act")
			shift
			;;
		-z | --archive=*)
			O_ARCHIVE="$arg"
			shift
			;;
		-D | --drop=*)
			O_DROP="$arg"
			shift
			;;
		--)
			shift
			break
			;;
		-*)
			# This was one of the common options that was already consumed by
			# the CLI module. git-revparse will not have normalized an
			# unrecognized option.
			shift
			;;
		*)
			break
			;;
		esac
	done

	if [ ${#O_ACTIONS} -eq 0 ]; then
		O_ACTIONS=("${G_DEFAULT_ACTIONS[@]}")
	fi

	if [ -n "$O_ARCHIVE" ]; then
		O_ACTIONS=("__archive")
	elif [ -n "$O_DROP" ]; then
		O_ACTIONS=("__drop")
	fi

	__cmd "$@"
}

__main "$@"
